// 증가하는 i에 대해 min(0..i-1 ^ i)를 쉽게 구하는 법
// http://codeforces.com/contest/959/problem/E
/*
각 i를 이진수로 표현하면 규칙성이 보인다.
1	 1
--
10	 2
11	 1
--
100	 4
101	 1
110	 2
111	 1
--
1000 8
1001 1
1010 2
1011 1
1100 4
1101 1
1110 2
1111 1

우선, 최상위 비트가 바뀌게 되면(10000...), 그 순간 min의 값은 2^x이다.
--> (0과 i를 xor 하는게 가장 이득, 최상위 비트를 0으로 바꾸는 순간 xor 값이 2^x를 초과해버리기 때문에 최상위 비트는 1로 고정한 상태에서 나머지 비트는 0으로 두는게 가장 낫다.)

그 후, 해당 자리수가 최상위 비트일 때를 생각하면, 최상위비트는 그대로 두되 i = 1..2^x-1 까지 다시 쌓이는 형태가 된다.
즉, 재귀적으로 하위가 최상위 비트일 때의 결과를 이용할 수 있는 것이다.
(10000.. -> 10000..1 -> ...)

n-bit = n자리 bit가 최상위 비트이고 나머지가 0인 경우라고 할 때(10000...) sum(min(0..i-1 ^ i)) i = 1..2^n의 결과라고 하면,
--> 즉, 2^n일 때 sum 연산의 결과
n-bit = 2^n + [sum(min(0..i-1 ^ i)) i = 1..2^n-1]
--> i = 2^n일 때는 위에서 말한 바와 같이 0과의 xor을 통해 2^n이 되고, 나머지 이 경우를 제외 한 합

[sum(min(0..i-1 ^ i)) i = 1..2^n-1]는 다시
sum(i-bit) i = 1..n-1로 쓸 수 있다.

따라서 n-bit = 2^n + sum(1..n-1 bit)
--> 11111.. 에서 10000..에 대해 구하고, 01000.., 00100.. 반복
--> 10000..에 대해 구했으면 0~10000..은 구해진 상태 --> 이제 1xxxx..에 대해 구하면 됨
    11000..에 대해 구했으면 0~11000..은 구해진 상태 ...


이제 sum(min(0..j-1 ^ j))  j = 1..i  를 구해보자
즉 n-1을 이진수로 표현했을 때 1인 부분에 대해 dp[i]를 더해주면 된다.
(원리는 위와 마찬가지)
(0~1000.. 완성했으면 1000~.. 를 재귀적으로 완성)

*/