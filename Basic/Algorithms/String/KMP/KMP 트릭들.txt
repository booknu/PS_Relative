<< 문자열 S가 어떤 가장 짧은 prefix의 반복으로 이루어져있는지 알아내기 >> --> https://www.acmicpc.net/problem/1305, https://www.acmicpc.net/problem/4354
즉, abcabcab가 있다면, abc가 반복되다가 마지막에 c가 짤린 형태라는걸 알아내는 것이다. (물론, c를 자르지 않고 반복하는 경우도 알 수 있다.)


pi 배열을 살펴보자.
pi[n-1]은 S 전체에서 pre = suf인 최대 길이이다.

이것을 그림으로 표현하면 다음과 같다.
    12345678
	abcabcab
pre |---|^^^
    ^^^|---| suf
	  
여기서 S[0..start_suf) 부분을 보자.
이 부분이 반복된다는 것을 직관적으로 알 수 있는데, 어떻게 이것이 가능할까?

start_pre = ps = 0, start_suf = ss = 0+len 라고 해보자.
또한 중복되는 부분을 x, 그 길이를 len이라고 두면,

S[ps..ps+len) = x이다.
pre = suf이기 때문에
S[ss..ss+len) = S[ps..ps+len] = x이다.
이 때, ss = 0+len이기 때문에, 첫 x 부분 바로 뒤에 또 x가 다시 오는 것이다.
이것은 문자열 전체에 대해 재귀적으로 성립해 결국 suffix의 마지막 남겨지는 부분이 남을 때까지 성립한다.


결론은 S가 어떤 가장 짧은 부분 문자열의 반복으로 이루어져있는지를 알고 싶으면, ss - ps를 구하고,
그것이 문자열에서 몇 번이나 반복되는지 알고 싶으면 n/len을 구하면 된다. (n%len 부분은 반복되고 남은 부분이다.)

여기서 마지막이 잘리지 않는 경우를 구하고 싶다면, n%len == 0인지를 확인하면 될 것이다.




<< 문자열 S의 prefix가 S에서 각각 몇 번씩 등장하는지? >> --> http://codeforces.com/contest/432/problem/D, http://codeforces.com/contest/126/problem/B
--> 이거 뭔가 Z-Algorithm과 관계 있는 것 같음.
문자열 S에는 n개의 prefix가 존재하고 있다.
S에 각각의 prefix가 몇 번이나 등장하는지를 O(n)에 세고 싶을 때 사용할 수 있는 기법이다.
(또한 pi 배열이 DAG 형태를 띄고 있다는 것도 알 수 있는 트릭이다.)


일단 pi 배열에 대한 정의를 살펴보자.
pi[i] = S[0..]과 S[..i]의 최대 공통 부분의 길이 (= pre, suf가 같은 최대 길이)

이것을 이용하면 최소한 각 i에서 끝나는 prefix = suffix가 최대인 prefix에 한해서는 그것이 i에서 끝난다는 정보를 얻을 수 있다.
그것보다 짧은 prefix가 i에서 끝나는지는 알 수 있는 방법이 없을까?

pi 배열 자체를 구할 때 사용했던 방법, 즉 실패함수를 사용하면 그것도 구할 수 있다.

일단 편하게 길이가 x인 prefix를 x라고 정의하자.
i에서 pi[i]가 등장한다는 것은 알 수 있다고 했다.
이것의 실패함수, 즉 suffix = prefix인 최대 길이를 따라가면 그보다 짧은 prefix에 대해서도 구할 수 있지 않을까?
즉, pi[pi[i]-1]도 i에서 등장한다는 것이다.

이것을 재귀적으로 적용하면 결국 i에서 끝나는 모든 prefix에 대해 알 수 있다.

이제 남은 일은 모든 i를 돌며 그곳에서 끝나는 prefix들에 대해 count를 해주는 것이다.

하지만 이 과정은 최대 O(n^2)이 걸린다.

여기서 pi[pi[i]-1], pi[pi[pi[i]-1]-1], ... 이 pi[i] = x인 x를 node로 하는 DAG 형태를 띈다는 점을 알아차리면, O(n)으로 시간을 줄일 수 있다.
또한 x는 하위 node로 갈 수록 작아질 수 밖에 없다는 점 역시 이해해야 한다.

일단 모든 i에 대해 ++cnt[pi[i]];를 적용해놓고, 상위 node에서부터 연결된 하위 node들에게 cnt를 전파(더하기)해주면 모든 x에 대해 cnt를 O(n)에 구할 수 있다!