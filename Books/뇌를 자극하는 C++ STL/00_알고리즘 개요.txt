[[ 주의사항 ]]
1. 탐색 알고리즘은 찾지 못했을 시 "찾는 구간"의 끝 반복자를 반환 (end()가 아님!!)

2. [b, e)를 처리하여 [t, t+(e-b))에 저장하는 알고리즘은 t+(e-b) 반복자를 반환한다.

3. 원소를 수정하는 알고리즘은 기본적으로 Overwrite로 작동된다.
   만약 insert로 사용하고 싶다면, 반복자 어댑터 insert_iterator을 사용해야 한다. (10장)

4. 제거 알고리즘은 원소를 실제로 제거하지 않고 논리적으로 제거(다음 원소로 덮어쓰기)한다.
   따라서 size는 변하지 않는다.

5. 제거 알고리즘은 제거를 하고 난 후의 순차열의 끝 반복자를 반환한다.


[[ 정렬 알고리즘 ]]
1. sort(b, e)
		QuickSort 방식으로 정렬한다.
		qsort는 c에 내장된 것이고 sort는 stl에 내장된 것이다.
		평균: O(N*logN)
		최악: O(N^2)

2. stable_sort(b, e)
		MergeSort 방식으로 정렬한다.
		비교자에서 같은 원소들의 상대적 순서가 유지된다.
		평균: O(N*log2N)
		메모리 부족시: O(N*log2N*log2N)

3. partial_sort(b, m, e)
		HeapSort 방식으로 정렬한다.
		순차열의 상위 구간만 정렬 할 수 있다.
		항상: O(N*log2N)

[[ 정렬된 범위 알고리즘 ]]
1. 모든 정렬된 범위 알고리즘에는 조건자 버전의 알고리즘이 제공된다.
   만약 default와 다른 방식으로 정렬되었다면, 이것을 꼭 인자로 넘겨주어야 한다.
   
   예를 들어, binary_search(b, e, x, f)가 있다면
   [b, e)에는 f기준으로 정렬된 원소들이 있어야 한다.
   이 때 ==을 판단하는 것은 equivalence 방식으로 !f(a, b) && !f(b, a) 이면 같은 값이다.

   ==> f가 a == b를 판단하는 기준이 아님에 주의!!!
   ==> f는 a보다 b가 뒤에 오는지를 판단하는 함수!

   ==> 연관 컨테이너는 정렬 기준을 내장하고 있으므로 이런건 없을듯?


[[ 수치 알고리즘 ]]
1. 수치 알고리즘은 <numeric>에 있다.